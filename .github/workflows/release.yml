# Nombre del workflow
name: Crear Release

# Variables de entorno globales para el workflow
env:
  NODE_VERSION: '20'
  DOTNET_VERSION: '8.x'
  REGISTRY_URL: 'gcr.io'
  GOOGLE_CLOUD_PROJECT: ${{ secrets.GCP_PROJECT_ID }}

# Disparadores del workflow
on:
  # Permite la ejecución manual desde la pestaña de Actions
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Tipo de release (major, minor, patch)'
        type: choice
        options: [patch, minor, major]
        default: 'patch'
        required: true
      custom_version:
        description: 'Opcional: Versión personalizada (ej. 1.2.3)'
        required: false
      pre_release:
        description: 'Marcar como pre-release'
        type: boolean
        default: false

  # Se ejecuta al hacer push a la rama principal
  push:
    branches:
      - main

# Definición de los trabajos (jobs) que se ejecutarán
jobs:
  # ============================================================================
  # 1. CALCULAR LA PRÓXIMA VERSIÓN Y EL CHANGELOG
  # ============================================================================
  calculate-version:
    name: 1. Calcular Versión y Changelog
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      is-release: ${{ steps.version.outputs.is-release }}
      changelog: ${{ steps.changelog.outputs.changelog }}
    steps:
      - name: Checkout del código
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Necesario para leer todos los commits

      - name: Calcular la próxima versión
        id: version
        run: |
          # Obtener la versión actual desde los tags de git
          CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          CURRENT_VERSION=${CURRENT_VERSION#v}
          echo "Versión actual: $CURRENT_VERSION"

          # Lógica para determinar la nueva versión
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ -n "${{ github.event.inputs.custom_version }}" ]; then
              NEW_VERSION="${{ github.event.inputs.custom_version }}"
            else
              IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
              MAJOR=${VERSION_PARTS[0]:-0}
              MINOR=${VERSION_PARTS[1]:-0}
              PATCH=${VERSION_PARTS[2]:-0}
              
              case "${{ github.event.inputs.release_type }}" in
                major) NEW_VERSION="$((MAJOR + 1)).0.0" ;;
                minor) NEW_VERSION="$MAJOR.$((MINOR + 1)).0" ;;
                *) NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))" ;;
              esac
            fi
            IS_RELEASE="true"
          else
            # Cálculo automático basado en mensajes de commit (Conventional Commits)
            COMMITS_SINCE_TAG=$(git rev-list v${CURRENT_VERSION}..HEAD --count 2>/dev/null || git rev-list HEAD --count)
            
            if [ $COMMITS_SINCE_TAG -eq 0 ]; then
              echo "No hay nuevos commits desde el último release."
              NEW_VERSION="$CURRENT_VERSION"
              IS_RELEASE="false"
            else
              COMMIT_MESSAGES=$(git log v${CURRENT_VERSION}..HEAD --pretty=format:"%s" 2>/dev/null || git log --pretty=format:"%s")
              IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
              MAJOR=${VERSION_PARTS[0]:-0}
              MINOR=${VERSION_PARTS[1]:-0}
              PATCH=${VERSION_PARTS[2]:-0}
              
              if echo "$COMMIT_MESSAGES" | grep -qE "(BREAKING CHANGE|feat!|fix!)"; then
                NEW_VERSION="$((MAJOR + 1)).0.0"
              elif echo "$COMMIT_MESSAGES" | grep -qE "^feat(\(.*\))?:"; then
                NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
              else
                NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
              fi
              IS_RELEASE="true"
            fi
          fi
          
          echo "Nueva versión: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "is-release=$IS_RELEASE" >> $GITHUB_OUTPUT

      - name: Generar changelog
        id: changelog
        if: steps.version.outputs.is-release == 'true'
        run: |
          # (Aquí iría el script completo para generar el changelog)
          # Por simplicidad, se muestra una versión reducida.
          echo "# Changelog para v${{ steps.version.outputs.version }}" > TEMP_CHANGELOG.md
          echo "" >> TEMP_CHANGELOG.md
          echo "**Fecha de Release:** $(date -u +"%Y-%m-%d")" >> TEMP_CHANGELOG.md
          echo "" >> TEMP_CHANGELOG.md
          echo "## 🚀 Cambios" >> TEMP_CHANGELOG.md
          git log $(git describe --tags --abbrev=0 2>/dev/null || echo HEAD~10)..HEAD --pretty=format:"- %s" >> TEMP_CHANGELOG.md
          
          CHANGELOG_CONTENT=$(cat TEMP_CHANGELOG.md | base64 -w 0)
          echo "changelog=$CHANGELOG_CONTENT" >> $GITHUB_OUTPUT

  # ============================================================================
  # 2. CONSTRUIR ARTEFACTOS DE RELEASE
  # ============================================================================
  build-assets:
    name: 2. Construir Artefactos
    runs-on: ubuntu-latest
    needs: calculate-version
    if: needs.calculate-version.outputs.is-release == 'true'
    strategy:
      matrix:
        include:
          - component: frontend
            path: frontend
          - component: backend
            path: backend/BabysitterApi
    steps:
      - name: Checkout del código
        uses: actions/checkout@v4

      - name: Configurar Node.js (Frontend)
        if: matrix.component == 'frontend'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Configurar .NET (Backend)
        if: matrix.component == 'backend'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Construir Frontend
        if: matrix.component == 'frontend'
        working-directory: frontend
        run: |
          npm ci
          npm run build
          tar -czf babysitter-frontend-v${{ needs.calculate-version.outputs.version }}.tar.gz -C build .
      
      - name: Construir Backend
        if: matrix.component == 'backend'
        working-directory: backend/BabysitterApi
        run: |
          dotnet restore
          dotnet publish -c Release -o publish --no-restore
          tar -czf babysitter-backend-v${{ needs.calculate-version.outputs.version }}.tar.gz -C publish .

      - name: Subir artefacto
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.component }}-release-v${{ needs.calculate-version.outputs.version }}
          path: ${{ matrix.path }}/babysitter-${{ matrix.component }}-v${{ needs.calculate-version.outputs.version }}.tar.gz

  # ============================================================================
  # 3. CONSTRUIR Y PUBLICAR IMÁGENES DOCKER
  # ============================================================================
  build-docker-images:
    name: 3. Construir Imágenes Docker
    runs-on: ubuntu-latest
    needs: calculate-version
    if: needs.calculate-version.outputs.is-release == 'true'
    permissions:
      contents: 'read'
      id-token: 'write'
    strategy:
      matrix:
        component: [frontend, backend]
    steps:
      - name: Checkout del código
        uses: actions/checkout@v4

      - name: Autenticar en Google Cloud
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: 'projects/${{ secrets.GCP_PROJECT_NUMBER }}/locations/global/workloadIdentityPools/${{ secrets.GCP_WIF_POOL }}/providers/${{ secrets.GCP_WIF_PROVIDER }}'
          service_account: '${{ secrets.GCP_SA_EMAIL }}'
          
      - name: Configurar Docker para GCR
        run: gcloud auth configure-docker ${{ env.REGISTRY_URL }}

      - name: Construir y publicar imágenes
        run: |
          VERSION="v${{ needs.calculate-version.outputs.version }}"
          IMAGE_NAME="babysitter-app-${{ matrix.component }}"
          DOCKERFILE_PATH="${{ matrix.component }}"
          BASE_URL="${{ env.REGISTRY_URL }}/${{ env.GOOGLE_CLOUD_PROJECT }}/${IMAGE_NAME}"
          
          docker build -t ${BASE_URL}:${VERSION} -t ${BASE_URL}:latest ${DOCKERFILE_PATH}/
          
          docker push ${BASE_URL}:${VERSION}
          docker push ${BASE_URL}:latest
          echo "Imagen publicada: ${IMAGE_NAME}:${VERSION}"

  # ============================================================================
  # 4. CREAR EL RELEASE EN GITHUB
  # ============================================================================
  create-release:
    name: 4. Crear Release en GitHub
    runs-on: ubuntu-latest
    needs: [calculate-version, build-assets]
    if: needs.calculate-version.outputs.is-release == 'true'
    steps:
      - name: Descargar artefactos de release
        uses: actions/download-artifact@v4
        with:
          path: release-assets

      - name: Crear Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.calculate-version.outputs.version }}
          name: Release v${{ needs.calculate-version.outputs.version }}
          body: ${{ needs.calculate-version.outputs.changelog }}
          draft: false
          prerelease: ${{ github.event.inputs.pre_release == 'true' }}
          files: |
            release-assets/frontend-release-v${{ needs.calculate-version.outputs.version }}/*
            release-assets/backend-release-v${{ needs.calculate-version.outputs.version }}/*

  # ============================================================================
  # 5. ACTIVIDADES POST-RELEASE (ACTUALIZAR VERSIÓN EN CÓDIGO)
  # ============================================================================
  post-release:
    name: 5. Actualizar Versión en Código
    runs-on: ubuntu-latest
    needs: [calculate-version, create-release]
    if: needs.calculate-version.outputs.is-release == 'true'
    steps:
      - name: Checkout del código
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }} # Usar un token para poder hacer push

      - name: Actualizar archivos de versión
        run: |
          VERSION="${{ needs.calculate-version.outputs.version }}"
          # Actualizar frontend/package.json
          sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" frontend/package.json
          # Actualizar backend .csproj
          find backend -name "*.csproj" -exec sed -i "s|<Version>.*</Version>|<Version>$VERSION</Version>|" {} \;

      - name: Hacer commit de los cambios
        run: |
          git config user.name "GitHub Action"
          git config user.email "action@github.com"
          git add frontend/package.json backend/**/*.csproj
          if ! git diff --staged --quiet; then
            git commit -m "chore(release): Actualizar versión a v${{ needs.calculate-version.outputs.version }} [skip ci]"
            git push
          else
            echo "No hay cambios de versión para commitear."
          fi